## Contents

- 연산자와 연산식
- 산술 연산자
- 비트 연산자
- 관계 연산자
- 논리 연산자
- instanceof (작성 예정)
- 대입 연산자
- 화살표(→) 연산자 (작성 예정)
- 3항 연산자
- 연산자 우선순위
- (Optional) Java 13. switch 연산자 (작성 예정)

---

## 연산자와 연산식

- 연산(Operations)
  : 프로그램에서 데이터를 처리하여 결과를 산출하는 것
- 연산자(Operator)
  : 연산에 사용되는 표시나 기호
- 피연산자(Operand)
  : 연산되는 데이터
- 연산식(expressions)
  : 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것

연산자는 피연산자를 연산해서 값을 산출하는데, **산출되는 값은 타입에 따라 연산자별로 다르다.** 예를 들어, 산술 연산자의 경우엔 숫자 타입으로 결과값이 나오고, 비교 연산자와 논리 연산자는 논리 타입으로 결과가 나온다.

또한, 연산자는 필요로 하는 피연산자의 수에 따라 `단항`, `이항`, `삼항 연산자`로 구분된다.

---

## 산술 연산자

| 연산식               | 설명                                                      |
| -------------------- | --------------------------------------------------------- |
| 피연산자 + 피연산자  | 덧셈 연산                                                 |
| 피연산자 - 피연산자  | 뺄셈 연산                                                 |
| 피연산자 \* 피연산자 | 곱셈 연산                                                 |
| 피연산자 / 피연산자  | 좌측 피연산자를 우측 피연산자로 나눗셈 연산               |
| 피연산자 % 피연산자  | 좌측 피연산자를 우측 피연산자로 나눈 나머지를 구하는 연산 |

### NaN과 Infinity

`/`와 `%` 연산자를 사용할 때 주의할 점이 있다. 우측 피연산자가 **0**을 사용할 수 없다. 컴파일은 정상적으로 되지만 예외가 발생한다.

연산의 결과가 Infinity 또는 NaN이 발생할 수 있는데, 해당 결과가 나왔을 때 다음 연산을 수행해서는 안된다. 왜냐하면 다음 연산을 수행하게 되면 결과가 엉망이 되기 때문이다.

연산의 결과가 Infinity 또는 NaN인지 확인하려면 **Double.inInfinite()**와 **Double.isNaN()**메소드를 이용하면 된다.

### 입력값의 NaN 검사

부동소수점(실수)을 입력받았을 때 **반드시 NaN 검사를 해야 한다.**

NaN은 산술 연산이 가능하기 때문에 NaN이라는 데이터가 들어왔다면 Double.isNaN()메소드를 이용해서 검사해주길 바란다.

---

## 비트 연산자

비트 연산자는 데이터를 비트(bit) 단위로 연산한다. 즉, 0과 1이 피연산자가 된다. 0과 1로 표현이 가능한 정수 타입만 비트 연산을 수행할 수 있다. 실수 타입은 비트 연산을 할 수 없다.

비트 연산자는 기능에 따라 `비트 논리 연산자(&, |, ^, ~)`와 `비트 이동 연산자(<<, >>, >>>)`로 구분한다.

### 비트 논리 연산자

| 구분               | 연산식 | 결과 | 설명                                                                |
| ------------------ | ------ | ---- | ------------------------------------------------------------------- |
| AND(논리곱)        | 1 & 1  | 1    | 두 비트 모두 1일 경우에만 연산 결과가 1이다.                        |
|                    | 1 & 0  | 0    |                                                                     |
|                    | 0 & 1  | 0    |                                                                     |
|                    | 0 & 0  | 0    |                                                                     |
| OR(논리합)         | 1 1    | 1    | 두 비트 중 하나만 1이면 연산 결과는 1이다.                          |
|                    | 1 0    | 1    |                                                                     |
|                    | 0 1    | 1    |                                                                     |
|                    | 0 0    | 0    |                                                                     |
| XOR(배타적 논리합) | 1 ^ 1  | 0    | 두 비트 중 하나는 1이고 다른 하나가 0일 경우에만 연산 결과는 1이다. |
|                    | 1 ^ 0  | 1    |                                                                     |
|                    | 0 ^ 1  | 1    |                                                                     |
|                    | 0 ^ 0  | 0    |                                                                     |
| NOT(논리 부정)     | ~ 1    | 0    | 보수                                                                |
|                    | ~ 0    | 1    |                                                                     |

위 표에서 논리합을 표현할 때 `|`을 이용하는데, 표와 겹쳐서 생략했다.

### 비트 이동 연산자

비트 이동 연산자는 **정수 데이터의 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산**이다.

| 구분         | 연산식  | 설명                                                                                                            |
| ------------ | ------- | --------------------------------------------------------------------------------------------------------------- |
| 이동(쉬프트) | a << b  | 정수 a의 각 비트를 b만큼 왼쪽으로 이동한다. (빈자리는 0으로 채워진다.)                                          |
|              | a >> b  | 정수 a의 각 비트를 b만큼 오른쪽으로 이동한다. (빈자리는 정수 a의 최상위 부호 비트(MSB)와 같은 값으로 채워진다.) |
|              | a >>> b | 정수 a의 각 비트를 b만큼 오른쪽으로 이동한다. (빈자리는 0으로 채워진다.)                                        |

---

## 관계 연산자

| 구분      | 연산식                 | 설명                                  |
| --------- | ---------------------- | ------------------------------------- |
| 동등 비교 | 피연산자1 == 피연산자2 | 두 피연산자의 값이 같은지를 검사한다. |
|           | 피연산자1 != 피연산자2 | 두 피연산자의 값이 다른지를 검사한다. |
| 크기 비교 | 피연산자1 > 피연산자2  | 피연산자1이 큰지를 검사한다.          |
|           | 피연산자 >= 피연산자2  | 피연산자1이 크거나 같은지를 검사한다. |
|           | 피연산자1 < 피연산자2  | 피연산자1이 작은지를 검사한다.        |
|           | 피연산자1 <= 피연산자2 | 피연산자1이 작거나 같은지를 검사한다. |

`String`타입의 문자열을 비교할 때는 대소 연산자를 이용할 수 없고, 동등 비교 연산자는 사용할 수 있지만 문자열이 같은지 다른지를 비교하는 용도로 사용되지 않는다.

`기본 타입`인 변수의 값을 비교할 때에는 `== 연산자`를 사용하지만 **참조 타입은 String 변수를 비교할 때 == 연산자를 사용하면 원하지 않는 결과가 나올 수도 있다.**

자바는 문자열 리터럴이 동일하다면 동일한 String 객체를 참조하도록 되어 있지만 객체 생성 연산자인 `new`로 생성한 String 객체는 다른 번지값을 가지고 있다.

```java
String a = "김아현";
String b = "김아현";
String c = new String("김아현");

a == b; // true
b == c; // false
```

그래서 String 객체의 문자열을 비교하고 싶을 땐 == 연산자 대신 **equals() 메소드를 사용**해야 한다.

`equals()`메소드는 원본 문자열과 매개값으로 주어지는 문자열이 동일한지 비교 후 true, false를 리턴한다.

```java
boolean result = a.equals(c); // true
```

---

## 논리 연산자

논리 연산자는 `논리곱(&&)`, `논리합(||)`. `배타적 논리합(^)`, `논리 부정(!)` 연산을 수행한다.

| 구분              | 연산식                | 결과  | 설명                                                                     |
| ----------------- | --------------------- | ----- | ------------------------------------------------------------------------ |
| AND(논리곱)       | true && 또는 & true   | true  | 피연산자 모두가 true일 경우에만 연산 결과 true                           |
|                   | true && 또는 & false  | false |                                                                          |
|                   | false && 또는 & true  | false |                                                                          |
|                   | false && 또는 & false | false |                                                                          |
| OR(논리합)        | true true             | true  | 피연산자 중 하나만 true이면 연산 결과는 true                             |
|                   | true false            | true  |                                                                          |
|                   | false true            | true  |                                                                          |
|                   | false false           | false |                                                                          |
| XOR(배타적논리합) | true ^ true           | false | 피연산자가 하나는 true이고 다른 하나가 false일 경우에만 연산 결과는 true |
|                   | true ^ false          | true  |                                                                          |
|                   | false ^ true          | true  |                                                                          |
|                   | false ^ false         | false |                                                                          |
| NOT(논리부정)     | ! true                | false | 피연산자의 논리값을 바꾼다.                                              |
|                   | ! false               | true  |                                                                          |

위 표에서 논리합을 계산할 때는 `||`또는 `|`을 이용한다. 표 레이아웃 형식과 겹쳐서 연산자는 제외하고 작성했다.

&&와 &는 연산 과정이 조금 다르다. &&는 앞의 피연산자가 false라면 뒤의 피연산자를 평가하지 않고 바로 false라는 결과를 낸다. &는 두 피연산자 모두를 평가해서 산출 결과를 낸다. 따라서 &가 &&보다 더 효율적으로 동작한다. ||와 |도 마찬가지이다.

---

## instanceof

---

## 대입 연산자

대입 연산자는 **오른쪽 피연산자의 값을 좌측 피연산자인 변수에 저장**한다.

대입 연산자에는 값을 변수에 저장하는 `단순 대입 연산자`와 정해진 연산을 수행 후 결과를 변수에 저장하는 `복합 대입 연산자`가 있다.

| 구분             | 연산식                      | 설명                                                                                                          |
| ---------------- | --------------------------- | ------------------------------------------------------------------------------------------------------------- | -------------------------------------------- | --------------------- |
| 단순 대입 연산자 | 변수 = 피연산자             | 우측의 피연산자의 값을 변수에 저장한다.                                                                       |
| 복합 대입 연산자 | 변수 += 피연산자            | 우측의 피연산자의 값을 변수의 값과 더한 후에 다시 변수에 저장한다. (변수 = 변수 + 피연산자와 동일하다.)       |
|                  | 변수 -= 피연산자            | 우측의 피연산자의 값을 변수의 값과 뺀 후에 다시 변수에 저장한다. (변수 = 변수 - 피연산자와 동일하다.)         |
|                  | 변수 \*= 피연산자           | 우측의 피연산자의 값을 변수의 값과 곱한 후에 다시 변수에 저장한다. (변수 = 변수 \* 피연산자와 동일하다.)      |
|                  | 변수 /= 피연산자            | 우측의 피연산자의 값으로 변수의 값을 나눈 후에 다시 변수에 저장한다. (변수 = 변수 / 피연산자와 동일하다.)     |
|                  | 변수 %= 피연산자            | 우측의 피연산자의 값으로 변수의 값을 나눈 후에 나머지를 변수에 저장한다. (변수 = 변수 % 피연산자와 동일하다.) |
|                  | 변수 &= 피연산자            | 우측의 피연산자의 값과 변수의 값을 & 연산 후 결과를 변수에 저장한다. (변수 = 변수 & 피연산자와 동일하다.)     |
|                  | 변수 논리합연산자= 피연산자 | 우측의 피연산자의 값과 변수의 값을                                                                            | 연산 후 결과를 변수에 저장한다. (변수 = 변수 | 피연산자와 동일하다.) |
|                  | 변수 ^= 피연산자            | 우측의 피연산자의 값과 변수의 값을 ^ 연산 후 결과를 변수에 저장한다. (변수 = 변수 ^ 피연산자와 동일하다.)     |
|                  | 변수 <<= 피연산자           | 우측의 피연산자의 값과 변수의 값을 << 연산 후 결과를 변수에 저장한다. (변수 = 변수 << 피연산자와 동일하다.)   |
|                  | 변수 >>= 피연산자           | 우측의 피연산자의 값과 변수의 값을 >> 연산 후 결과를 변수에 저장한다. (변수 = 변수 >> 피연산자와 동일하다.)   |
|                  | 변수 >>>= 피연산자          | 우측의 피연산자의 값과 변수의 값을 >>> 연산 후 결과를 변수에 저장한다. (변수 = 변수 >>> 피연산자와 동일하다.  |

위 표에서 `논리합연산자=`은 `|=`을 의미한다.

---

## 화살표(→) 연산자

---

## 3항 연산자

삼항 연산자(?:)는 세 개의 피연산자를 필요로 하는 연산자를 말한다. \*\*? 앞의 조건식에 따라 콜론(:) 앞뒤의 피연산자가 선택된다고 해서 조건 연산식이라고도 부른다.

```
조건식(피연산자1) ? 값 또는 연산식(피연산자2) : 값 또는 연산식(피연산자3)
```

조건식을 연산하여 true가 나오면 삼항 연산자의 결과는 피연산자2가 된다. 조건식을 연산하여 false가 나오면 결과는 피연산자3이 된다. 피연산자2와 피연산자3에는 주로 값이 오지만 경우에 따라서 연산식이 올 수도 있다.

---

## 연산자 우선 순위

프로그램에서는 **연산자의 연산 방향과 연산자 간의 우선순위**가 정해져 있다.

### 연산 방향과 우선순위

| 연산자                                    | 연산 방향          | 우선 순위 |
| ----------------------------------------- | ------------------ | --------- | ---- |
| 증감(++, —), 부호(+, -), 비트(~), 논리(!) | <————————          | 높음      |
| 산술(\*, /, %)                            | ————————>          |           |
| 산술(+, -)                                | ————————>          |           |
| 쉬프트(<<, >>, >>>)                       | ————————>          |           |
| 비교(<, >, <=, >=, instanceof)            | ————————>          |           |
| 비교(==, !=)                              | ————————>          |           |
| 논리(&)                                   | ————————>          |           |
| 논리(^)                                   | ————————>          |           |
| 논리(논리합1)                             | ————————>          |           |
| 논리(&&)                                  | ————————>          |           |
| 논리(논리합2)                             | ————————>          |           |
| 조건(?:)                                  | ————————>          |           |
| 대입(=, +=, -=, \*=, /=, %=, &=, ^=,      | =, <<=, >>=, >>>=) | <———————— | 낮음 |

위 표에서 `논리합1`은 `|`을 의미하고, `논리합2`는 `||`을 의미한다.

위와 같이 우선순위와 연산 방향이 정해져있지만 여러가지 연산자가 섞여 있다면 어느 연산자가 먼저 처리될지 혼란스러울 수도 있으니 `괄호()`를 사용하는 것을 추천한다.

---

## (Optional) Java 13. switch 연산자
