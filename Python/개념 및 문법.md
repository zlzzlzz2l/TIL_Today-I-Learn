# **개념 및 문법**

## 파이썬 자료형

: 정수형, 실수형, 복소수형, 문자열, 리스트, 튜플, 사전 등

### 수 자료형

- 정수형

  : 정수를 다루는 자료형

- 실수형

  : 소수점 아래의 데이터를 포함하는 수 자료형

  : 파이썬에서는 변수에 소수점을 붙인 수를 대입하면 실수형 변수로 처리한다.

  - 지수 표현 방식

    $유효숫자e^{지수} = 유효숫자*10^{지수}$

    지수 표현 방식은 임의의 큰 수를 표현하기 위해 사용한다. 최단 경로 알고리즘(ex. 그래프)에서는 도달할 수 없는 노드에 대하여 최단 거리를 무한(INF)로 설정하곤 하는데, 이 때 가능한 최댓값이 10억 미만이라면 무한(INF)의 값으로 1e9를 이용할 수 있다.

    e나 E를 이용해서 사용 가능하다.

  실수형을 저장하기 위해 4byte나 8byte의 고정된 메모리를 컴퓨터가 할당한다.

  10진수는 `0.3 + 0.6 = 0.9`로 떨어지지만 2진수는 `0.3 + 0.6 = 0.89999`로 0.9와 최대한 가깝게 표현되지만 오차가 있다. 그래서 컴퓨터는 실수 정보를 표현하는 정확도가 떨어지기 때문에 개발 과정에서 실수값을 제대로 비교하지 못해 원하는 결과를 얻지 못할 수 있다.

  ⇒ `round() 함수`를 이용하면 위 문제가 해결되고, 권장한다.

  ```python
  a = 123.456
  round(a, 2) # 소수 셋째 자리에서 반올림

  # 123.46
  ```

**수 자료형의 연산**

- 수 자료형은 사칙연산과 나머지 연산자가 많이 사용된다.
- `나누기 연산자(/)`는 실수형으로 반환한다.
- `나머지 연산자(%)`를 사용해야 될 때가 많다. (ex. 홀수인지 아닌지 판단할 때)
- `몫 연산자(//)`는 몫을 얻기 위해 사용한다.
- `거듭제곱 연산자(**)`를 비롯해 다양한 연산자들이 존재한다.

---

### 리스트 자료형

: 여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형이다.

- 사용자 입장에서 C나 자바에서의 배열의 기능 및 연결리스트와 유사한 기능을 지원한다.
- 리스트 대신에 배열 또는 테이블이라고 부른다.

**리스트 초기화**

리스트는 대괄호(`[]`)안에 원소를 넣어 초기화하며, 쉼표(`,`)로 원소를 구분한다.

비어있는 리스트를 선언하고자 할 때 `list()` 또는 `[]`를 이용할 수 있다.

리스트 원소에 접근할 때는 인덱스(Index) 값을 괄호에 넣는다.

```python
# 크기가 n이고, 모든 값이 0인 1차원 리스트
n = 10
a = [0] * n

# [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

**리스트의 인덱싱과 슬라이싱**

인덱스 값을 입력하여 리스트의 특정한 원소에 접근하는 것을 `인덱싱(Indexing)`이라고 한다.

- 파이썬의 경우 인덱스 값은 양의 정수와 음의 정수를 모두 사용할 수 있다.
- 음의 정수를 넣으면 원소를 거꾸로 탐색하게 된다.

리스트에서 연속적인 위치를 갖는 원소들을 가져와야 할 때는 `슬라이싱(slicing)`을 이용한다.

- 대괄호 안에 토큰(`:`)을 넣어서 시작 인덱스와 끝 인덱스를 설정할 수 있다.
- **끝 인덱스는 실제 인덱스보다 1을 더 크게 설정한다.**

  ```python
  a = [1, 2, 3, 4, 5, 6]
  print(a[3]) # 4
  print(a[1:4]) # [2, 3, 4]
  ```

**리스트 Comprehension**

: 리스트를 초기화하는 방법 중 하나이다.

: 대괄호 안에 `조건문과 반복문을 적용`하여 리스트를 초기화한다.

```python
# i라는 원소를 증가시키면서 a라는 list에 넣는다.
a = [ i for i in range(10)] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 0부터 9까지 수 중에서 홀수만 포함하는 리스트
a = [ i for i in range(10) if i % 2 == 1] # [1, 3, 5, 7, 9]

# 1부터 9까지의 수들의 제곱값을 포함하는 리스트
a = [i * i for i in range(1, 10)] # [1, 4, 9, 16, 25, 36, 49, 64, 81]
```

```python
# 리스트 Comprehension
a = [i for i in range(10) if i % 2 == 1]

# 일반 코드
a = []
for i in range(10):
	if i % 2 == 1:
		a.append(i)

# [1, 3, 5, 7, 9]
```

리스트 컴프리헨션은 2차원 리스트를 초기화할 때 효과적으로 사용될 수 있다.

특히 N X M 크기의 2차원 리스트를 한 번에 초기화할 때 유용하다.

- array = [[0] \* m for \_ in range(n)]

  ```python
  n = 4
  m = 3
  a = [[0] * m for _ in range(n)]
  print(a)

  # [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
  ```

  ![image](https://user-images.githubusercontent.com/48669011/134810055-d7ff2c4a-6133-4651-a392-ef3fe62b567e.png)

아래와 같이 리스트를 초기화한다면 예기치 않은 결과가 나올 수 있다.

- array = [[0] _ m] _ n

  전체 리스트 안에 포함된 각 리스트가 모두 같은 객체(같은 주소)로 인식된다.

  ```python
  n = 4
  m = 3
  a = [[0] * m] * n
  print(a)

  a[1][1] = 5
  print(a)

  # [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
  # [[0, 5, 0], [0, 5, 0], [0, 5, 0], [0, 5, 0]]
  ```

  ![image](https://user-images.githubusercontent.com/48669011/134810072-dafaabfb-4f21-4c14-9e0a-39a747760ade.png)

  ![image](https://user-images.githubusercontent.com/48669011/134810088-56378869-a942-4772-8758-617b4583d197.png)

  특정한 위치의 값인 1행 1열의 데이터를 바꾸려고 했는데 , 모든 1 인덱스의 값들이 바뀐 걸 확인할 수 있다.

**언더바(\_) 사용하기**

파이썬에서는 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 `언더바(_)`를 자주 사용한다.

```python
# 1부터 9까지 자연수 더하기
s = 0
for i in range(1, 10):
	s += i

print(s)

# 문자열 여러번 출력하기
for _ in range(5):
	print("Hello World")
```

**리스트 관련 기타 메서드**

| 함수명    | 사용법                                       | 설명                                                                            | 시간복잡도 |
| --------- | -------------------------------------------- | ------------------------------------------------------------------------------- | ---------- |
| append()  | 변수명.append()                              | 리스트에 원소를 하나 삽입할 때 사용한다. (뒤에서부터 삽입)                      | O(1)       |
| sort()    | 변수명.sort()                                | 기본 정렬 기능으로 오름차순으로 정렬한다.                                       | O(NlogN)   |
|           | 변수명.sort(reverse=True)                    | 내림차순으로 정렬한다.                                                          |            |
| reverse() | 변수명.reverse()                             | 리스트의 원소의 순서를 모두 뒤집어 놓는다.                                      | O(N)       |
| insert()  | 변수명.insert(삽입할 위치 인덱스, 산입할 값) | 특정한 인덱스 위치에 원소를 삽입할 때 사용한다.                                 | O(N)       |
| count()   | 변수명.count(특정 값)                        | 리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용한다.                   | O(N)       |
| remove()  | 변수명.remove(특정 값)                       | 특정한 값을 갖는 원소를 제거하는데, 값을 가진 원소가 여러 개면 하나만 제거한다. | O(N)       |

`remove()`메소드 같은 경우에는 특정한 값 하나만 삭제해준다. 특정 값이 여러 개 존재해도 그 값 중 하나만 삭제한다. 전체를 삭제하는 메소드는 파이썬에 없기 때문에 아래와 같이 코드를 작성할 수 있다.

```python
a = [1, 2, 3, 4, 5, 5, 5, 5]
remove_set = {3, 5} # 집합 자료형

# remove_set에 포함되지 않은 값만 저장하기
result = [i for i in a if i not in remove_set]
print(result)

# [1, 2, 4]
```

---

### 문자열 자료형

: 문자열 변수를 초기화할 때는 큰 따옴표(`"`)나 작은 따옴표(`'`)를 이용한다.

: 문자열 안에 큰 따옴표나 작은 따옴표가 포함되어야 하는 경우가 있다.

- 전체 문자열을 큰 따옴표로 구성한 경우, 내부적으로 작은 따옴표를 포함할 수 있다.
- 전체 문자열을 작은 따옴표로 구성한 경우, 내부적으로 큰 따옴표를 포함할 수 있다.
- 백슬래시(`\`)를 사용하면 큰 따옴표나 작은 따옴표를 원하는 만큼 포함할 수 있다.

```python
s = 'Hello'
print(s)

s = "Hello \"Ahyun\""
print(s)

# Hello
# Hello "Ahyun"
```

**문자열 연산**

문자열 변수는 `덧셈(+)`과 `곱셈(*)`을 이용할 수 있다.

문자열 변수에 **덧셈(+)을 이용하면 문자열이 더해져서 연결**된다.

문자열 변수를 특정한 **양의 정수와 곱하는 경우에는 문자열이 그 값만큼 여러번 더해진다.**

문자열에 대해서도 `인덱싱과 슬라이싱`을 이용할 수 있다.

- 다만 문자열은 특정 인덱스 값을 변경할 수는 없다. (Immutable)

```python
a = "Hi"
b = "Ahyun"

print(a + " " + b)
# Hi Ahyun

a = "abc"
print(a * 3)
# abcabcabc

a = "abcdef"
print(a[2:4])
# cd
```

---

### 튜플 자료형

튜플 자료형은 리스트와 유사하지만 문법적인 차이가 있다.

- 튜플은 한 번 선언된 값을 변경할 수 없다.
- 리스트는 대괄호(`[]`)를 이용하지만 튜플은 소괄호(`()`)를 이용한다.

선언된 값을 변경할 수 없고, 적은 양의 메모리를 사용하기 때문에 튜플은 리스트에 비해 상대적으로 공간 효율적이다.

```python
a = (1, 2, 3, 4, 5)
print(a[2])
# 3

print(a[2:4])
# (3, 4)
```

**튜플을 사용하면 좋은 경우**

- **서로 다른 성질**의 데이터를 묶어서 관리해야 할 때
  - 최단 경로 알고리즘에서는 (비용, 노드 번호)의 형태로 튜플 자료형을 자주 사용한다.
- 데이터의 나열을 **해싱(Hashing)의 키 값**으로 사용해야 할 때
  - 튜플은 변경이 불가능하기 때문에 리스트와 다르게 키 값으로 사용될 수 있다.
- 리스트보다 **메모리를 효율적**으로 사용해야 할 때

---

### 사전 자료형

사전 자료형은 `키(key)`와 `값(value)`의 상을 데이터로 가지는 자료형이다.

- 리스트나 튜플이 값을 순차적으로 저장하는 것과는 대비된다.

키와 값의 쌍을 데이터로 가지며, 원하는 `변경 불가능한(Immutable) 자료형`을 키로 사용할 수 있다.

파이썬의 사전 자료형은 해시 테이블을 이용하므로 **데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리**할 수 있다.

사전 자료형은 키 값으로 데이터를 찾는다.

```python
data = dict() # 초기화 - 1
data['사과'] = 'apple' # 할당
data['바나나'] = 'banana'
data['포도'] = 'grape'

data1 = { # 초기화 - 2
	'사과': 'apple', # 할당
	'바나나': 'banana',
	'포도': 'grape'
}

print(data)
print(data1)
# {'사과': 'apple', '바나나': 'banana', '포도': 'grape'}
# {'사과': 'apple', '바나나': 'banana', '포도': 'grape'}
```

**사전 자료형 관련 메서드**

키와 값을 별도로 뽑아내기 위한 메서드를 지원한다.

- 키 데이터만 뽑아서 리스트로 이용할 때는 `keys()`함수를 이용한다.
- 값 데이터만 뽑아서 리스트로 이용할 때는 `values()` 함수를 이용한다.

```python
# 위에 선언한 사전으로 키와 값 출력

key_list = data1.keys() # 사전키로 반환
# dict_keys(['사과', '바나나', '포도'])

key_list = list(data1.keys()) # list형 데이터로 형변환
# ['사과', '바나나', '포도']

print(data1['바나나']) # banana
```

---

### 집합 자료형

집합은 아래와 같은 특징이 있다.

- 중복을 허용하지 않는다.
- 순서가 없다.

위와 같은 특징 때문에 데이터가 존재하는지, 존재하지 않는지 그 여부만을 체크할 때 효과적이다.

집합은 **리스트 혹은 문자열을 이용해서 초기화**할수 있다.

- 이 때 `set()` 함수를 이용한다.

혹은 중괄호(`{}`)안에 각 원소를 콤마(,)를 기준으로 구분하여 삽입함으로써 초기화할 수 있다.

데이터 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.

```python
data = set([1, 1, 2, 2, 3]) # 초기화
print(data) # [1, 2, 3]

data = {1, 1, 2, 2, 3} # 초기화
print(data) # [1, 2, 3]
```

**집합 자료형의 연산**

기본적인 집합 연산으로는 합집합, 교집합, 차집합 연산 등이 있다.

- `합집합`: 집합 A에 속하거나 B에 속하는 원소로 이루어진 집합 $(A \cup B)$
- `교집합`: 집합 A에도 속하고 B에도 속하는 원소로 이루어진 집합 $(A \cap B)$
- `차집합`: 집합 A의 원소 중에서 B에 속하지 않는 원소들로 이루어진 집합 $(A - B)$

```python
a = set([1, 2, 3, 4, 5])
b = {3, 4, 5, 6, 7}

# 합집합
print(a | b)
# {1, 2, 3, 4, 5, 6, 7}

# 교집합
print(a & b)
# {3, 4, 5}

# 차집합
print(a - b)
# {1, 2}
```

**집합 자료형 관련 함수**

```python
data = set([1, 2, 3])
print(data)
# {1, 2, 3}

# 새로운 원소 추가
data.add(4)
print(data)
# {1, 2, 3, 4}

# 새로운 원소 여러 개 추가
data.update([5, 6])
print(data)
# {1, 2, 3, 4, 5, 6}

# 특정한 값을 갖는 원소 삭제
data.remove(4)
print(data)
# {1, 2, 3, 5, 6}
```

**사전 자료형과 집합 자료형의 특징**

리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있다.

사전 자료형과 집합 자료형은 **순서가 없기 때문에** 인덱싱으로 값을 얻을 수 없다.

- 사전의 키(key) 혹은 집합의 원소(Element)를 이용해 **O(1)**의 시간 복잡도로 조회한다.

---

### 기본 입출력

모든 프로그램은 적절한 (약속된) 입출력 양식을 가지고 있다.

프로그램 동작의 첫 번째 단계는 데이터를 입력 받거나 생성하는 것이다.

**자주 사용되는 표준 입력 방법**

- `input()` 함수는 **한 줄의 문자열을 입력 받는 함수**이다.
- `map()` 함수는 **리스트의 모든 원소에 각각 특정한 함수를 적용할 때 사용**한다.

  ex) 공백을 기준으로 구분된 데이터를 입력 받을 때 다음과 같이 사용한다.

  list(map(int, input().split())) : 데이터를 입력 받는데 공백을 기준으로 자르고, map 함수를 이용해서 정수형으로 변환한 뒤 리스트로 데이터를 받는다.

  ex) 공백을 기준으로 구분된 데이터의 개수가 많지 않다면, 다음과 같이 사용해도 된다.

  a, b, c = map(int, input().split()) : a, b, c에 차례대로 넣는다.

```python
n = int(input()) # 데이터의 개수 입력

data = list(map(int, input().split()))

data.sort(reverse=True)
print(data)

# 입력된 데이터
3
10 30 20
# 출력된 데이터
30 20 10
```

**빠르게 입력 받기**

사용자로부터 **입력을 최대한 빠르게 받아야 하는 경우**가 있다.

파이썬의 경우 sys 라이브러리에 정의되어 있는 `sys.stdin.readline()` 메서드를 이용한다.

→ 단, 입력 후 엔터(Enter)가 줄 바꿈 기호로 입력되므로 `rstrip()` 메서드를 함께 사용한다.

`이진탐색`, `정렬`, `그래프` 문제에서 자주 사용되는 테크닉이다.

```python
import sys

# 문자열 입력받기
data = sys.stdin.readline().rstrip()
print(data)
```

**자주 사용되는 표준 출력 방법**

파이썬에서 기본 출력은 `print()` 함수를 이용한다.

→ 각 변수를 콤마(,)를 이용하여 띄어쓰기로 구분하여 출력할 수 있다.

`print()`는 **기본적으로 출력 이후에 줄 바꿈을 수행**한다.

→ 줄 바꿈을 원치 않는 경우 `end` 속성을 이용하여 끝 맺음을 바꿔줄 수 있다. python은 end가 기본적으로 `\n`로 설정되어 있다.

```python
a = 1
b = 2
print(a, b) # 1 2

print(7, end=" ") # 출력이후에 띄어쓰기 하기
# 7

print(8, end="") # 출력만 하기
# 8

s = 9
print("이 숫자는" + str(s) + "입니다.")
# 이 숫자는 9입니다.
# 정수형은 문자열과 같이 출력할 수 없기 때문에 문자열로 변환해줬다.
```

**f-string**

파이썬 3.6부터 사용 가능하며, 문자열 앞에 접두사 `f`를 붙여 사용한다.

중괄호 안에 변수명을 기입하여 문자열과 정수를 함께 넣을 수 있다.

f-string을 이용하면 번거롭게 숫자형을 문자열로 변환해주지 않아도 된다.

```python
s = 9
print(f"이 숫자는 {s}입니다.")

# 이 숫자는 9입니다.
```

---

### 조건문

조건문은 **프로그램의 흐름을 제어하는 문법**이다.

조건에 따라서 프로그램의 로직을 설정할 수 있다.

```python
x = 10

if x >= 10:
	print("x >= 10")

if x >= 0:
	print("x >= 0")

if x >= 15:
	print("x >= 15")

# x >= 10
# x >= 0
```

**들여쓰기**

파이썬에서는 **코드의 블록(Block)을 들여쓰기(Indent)로 지정**한다.

**4개의 공백 문자를 사용하는 것을 표준으로 설정**하고 있다.

**조건문의 기본 형태**

조건문의 기본적인 형태는 **if ~ elif ~ else**이다.

→ 조건문을 사용할 때 elif 또는 else 부분은 경우에 따라서 사용하지 않아도 된다.

```python
if 조건문 1:
	조건문 1이 True일 때 실행되는 코드
elif 조건문 2:
	조건문 1에 해당하지 않고, 조건문 2가 True일 때 실행되는 코드
else:
	위의 모든 조건문이 모두 True 값이 아닐 때 실행되는 코드
```

**비교 연산자**

비교 연산자는 특정한 두 값을 비교할 때 이용할 수 있다.

→ `대입 연산자(=)`와 `같음 연산자(==)`의 차이점에 유의하자.

| 비교연산자 | 설명                                   |
| ---------- | -------------------------------------- |
| X == Y     | X와 Y가 서로 같을 때 참(True)이다.     |
| X != Y     | X와 Y가 서로 다를 때 참(True)이다.     |
| X > Y      | X가 Y보다 클 때 참(True)이다.          |
| X < Y      | X가 Y보다 작을 때 참(True)이다.        |
| X >= Y     | X가 Y보다 크거나 같을 때 참(True)이다. |
| X <= Y     | X가 Y보다 작거나 같을 때 참(True)이다. |

**논리 연산자**

논리 연산자는 **논리 값(True/False) 사이의 연산을 수행할 때 사용**한다.

| 논리연산자 | 설명                                           |
| ---------- | ---------------------------------------------- |
| X and Y    | X와 Y가 모두 참(True)일 때 참(True)이다.       |
| X or Y     | X와 Y 중에 하나만 참(True)이어도 참(True)이다. |
| not X      | X가 거짓(False)일 때 참(True)이다.             |

**파이썬의 기타 연산자**

다수의 데이터를 담는 자료형을 위해 `in 연산자`와 `not in 연산자`가 제공된다.

→ `리스트`, `튜플`, `문자열`, `딕셔너리` 모두에서 사용 가능하다.

| in 연산자와 not in 연산자 | 설명                                              |
| ------------------------- | ------------------------------------------------- |
| x in 리스트               | 리스트 안에 x가 들어가 있을 때 참(True)이다.      |
| x not in 문자열           | 문자열 안에 x가 들어가 있지 않을 때 참(True)이다. |

**파이썬의 pass 키워드**

**아무것도 처리하고 싶지 않을 때 pass 키워드를 사용한다.**

ex) 디버깅 과정에서 일단 조건문의 형태만 만들어 놓고 조건문을 처리하는 부분은 비워놓고 싶은 경우

```python
score = 85

if score >= 80:
	pass
else:
	print('성적이 80점 미만입니다.')

print('프로그램을 종료합니다.')

# 프로그램을 종료합니다.
```

**조건문의 간소화**

조건문에서 실행될 소스코드가 한 줄인 경우, 굳이 줄 바꿈을 하지 않고도 간략하게 표현할 수 있다.

```python
score = 85

if score >= 80: result = "Success"
else: result = "Fail"

# Success
```

조건부 표현식(Conditional Expression)은 **if ~ else문을 한 줄에 작성**할 수 있도록 해준다.

```python
score = 85

# 참 값일 때 왼쪽, 거짓일 때 오른쪽
result = "Success" if score >= 80 else "Fail"

print(result)

# Success
```

**파이썬 조건문 내에서의 부등식**

다른 프로그래밍 언어와 다르게 파이썬은 조건문 안에서 수학의 부등식을 그대로 사용할 수 있다.

ex) $x > 0$ and $x < 20$과 $0 < x < 20$은 같은 결과를 반환한다.

```python
# 코드 1
x = 15:
if x > 0 and x < 20:
	print("x는 0이상 20미만의 수 입니다.")

# 코드 2
x = 15:
if 0 < x < 20:
	print("x는 0이상 20미만의 수 입니다.")
```

다른 언어와 헷갈리지 않게 최대한 `코드 1`로 활용하자.

---

### 반복문

특정한 소스코드를 **반복적으로 실행하고자 할 때 사용하는 문법**이다.

파이썬에서는 `while문`과 `for문`이 있는데, 어떤 것을 사용해도 상관없다.

→ 다만 코딩 테스트에서 실제 사용 예시를 확인해보면, `for문`이 더 간결한 경우가 많다.

```python
# 1부터 9까지 모든 정수의 합 구하기 예제(while문)

i = 1
result = 0

# i가 9보다 작거나 같을 때 아래 코드를 반복적으로 실행
while i <= 9:
	result += i
	i += 1

print(result)

# 45

# 1부터 9까지 홀수의 합 구하기 예제(while문)
i = 1
result = 0

# i가 9보다 작거나 같을 때 아래 코드를 반복적으로 실행
while i <= 9:
	if i % 2 == 1:
		result += i
	i += 1

print(result)

# 25
```

**반복문에서의 무한 루프**

`무한 루프(Infinite Loop)`란 끊임없이 반복되는 반복 구문을 의미한다.

→ 코딩 테스트에서 무한 루프를 구현할 일은 거의 없으니 유의해야 한다.

→ 반복문을 작성한 뒤에는 항상 반복문을 탈출할 수 있는지 확인한다.

```python
x = 10

while x > 5:
	print(x)

# 10
# 10
# ...
```

**반복문 : for문**

반복문으로 for문을 이용할 수도 있다.

for문의 구조는 아래와 같은데, 특정한 변수를 이용하여 `in`뒤에 오는 **데이터(리스트, 튜플 등)에 포함되어 있는 원소를 첫 번째 인덱스부터 차례대로 하나씩 방문**한다.

```python
# 어떠한 변수가 리스트 안에 있는 값을 하나씩 방문할 것인지(?)
for 변수 in 리스트:
	실행할 코드

a = [1, 2, 3, 6, 9]

for x in a: # x가 a의 원소를 하나씩 방문
	print(x)

# 1
# 2
# 3
# 6
# 9
```

for문에서 연속적인 값을 차례대로 순회할 때는 `range()`를 주로 사용한다.

→ 이 때 range(시작 값, 끝 값 + 1) 형태로 사용한다.

→ 인자를 하나만 넣으면 자동으로 시작 값은 0이 된다.

```python
result = 0

for i in range(1, 11):
	result += i

print(result)

# 45
```

**파이썬의 continue 키워드**

반복문에서 남은 코드의 실행을 건너뛰고, 다음 반복을 진행하고자 할 때 `continue`를 사용한다.

1부터 9까지의 홀수 합을 구할 때 다음과 같이 작성할 수 있다.

```python
result = 0

for i in range(1, 10):
	if i % 2 == 0:
		continue
	result += i

print(result)

# 25
```

**파이썬의 break 키워드**

반복문을 즉시 탈출하고자 할 때 `break`를 사용한다.

1부터 5까지의 정수를 차례대로 출력하고자 할 때 다음과 같이 작성할 수 있다.

```python
result = 0

while True:
	print("현재 result값:", i)
	if result == 5:
		break
	result += 1

# 현재 result값: 1
# 현재 result값: 2
# 현재 result값: 3
# 현재 result값: 4
# 현재 result값: 5
```

---

### 함수와 람다 표현식

**함수**

함수(Function)란 **특정한 작업을 하나의 단위로 묶어 놓은 것을 의미**한다.

함수를 사용하면 불필요한 소스코드의 반복을 줄일 수 있다.

**함수의 종류**

- 내장 함수 : 파이썬이 기본적으로 제공하는 함수
- 사용자 정의 함수 : 개발자가 직접 정의하여 사용할 수 있는 함수

**함수 정의하기**

프로그램에는 똑같은 코드가 반복적으로 사용되어야 할 때가 많다.

**함수를 사용하면 소스코드의 길이를 줄일 수 있다.**

- 매개변수 : 함수 내부에서 사용할 변수
- 반환 값 : 함수에서 처리 된 결과를 반환

  ```python
  def 함수명(매개변수):
  	실행할 코드
  	return 반환 값

  # 매개변수와 반환 값은 존재하지 않을 수도 있다.
  ```

**더하기 함수 예시**

```python
# 예시 1
def add(a, b):
	return a + b

print(add(3, 7))

# 10

# 예시 2
def add(a, b):
	print('더하기 결과: ', a + b)

add(3, 7)

# 더하기 결과: 10
```

**파라미터 지정하기**

**파라미터의 변수를 직접 지정**할 수 있다.

→ 이 경우 매개변수의 순서가 달라도 상관없다.

```python
def add(a, b):
	return a + b

print(add(b = 7, a = 3))

# 10
```

**global 키워드**

global 키워드로 변수를 지정하면 해당 함수에서는 지역 변수를 만들지 않고, **함수 바깥에 선언된 변수를 바로 참조**하게 된다.

리스트 같은 경우에는 global 키워드를 등록하지 않아도 함수 바깥에 선언된 리스트를 참조할 수 있다.

```python
a = 0

def func():
	global a
	a += 1

for i in range(10):
	func()

print(a)

# 10
```

**여러 개의 반환 값**

파이썬에서 함수는 여러 개의 반환 값을 가질 수 있다.

```python
def op(a, b):
	addOp = a + b
	subsOp = a - b
	multiOp = a * b
	diviOp = a / b
	return addOp, subOp, multiOp, diviOp

a, b, c, d = op(7, 3) # 반환 값들이 차례대로 변수에 대입된다.
print(a, b, c, d)

# 10 4 21 2.1(?)
```

**람다 표현식**

람다 표현식을 이용하면 함수를 간단하게 작성할 수 있다.

→ 특정한 기능을 수행하는 함수를 한 줄에 작성할 수 있다는 점이 특징이다.

```python
def add(a, b):
	return a + b

print(add(3, 7)) # 10

print((lambda a, b: a + b)(3, 7)) # 10

# lambda 입력값: 반환값(매개변수)
```

**람다 표현식 예시 : 내장 함수에서 자주 사용되는 람다 함수**

```python
a = [('a', 30), ('b', 50), ('c', 40)]

def a_key(x):
	return x[1]

# sorted(리스트, 정렬 기준)

print(sorted(a, key=a_key)) # [('a', 30), ('c', 40), ('b', 50)]

print(sorted(a, key=lambda x: x[1])) # [('a', 30), ('c', 40), ('b', 50)]
```

**람다 표현식 예시 : 여러 개의 리스트에 적용**

```python
list1 = [1, 2, 3, 4, 5]
list2 = [6, 7, 8, 9, 10]

result = map(lambda a, b: a + b, list1, list2)

print(list(result)) # [7, 9, 11, 13, 15]
```

---

### 실전에서 유용한 표준 라이브러리

- 내장 함수 : 기존 입출력 함수부터 정렬 함수까지 기본적인 함수들을 제공한다.

  → 파이썬 프로그램을 작성할 때 없어서는 안되는 필수적인 기능을 포함하고 있다.

  ```python
  # sum()
  result = sum([1, 2, 3, 4, 5])
  print(result) # 15

  # min(), max()
  min_result = min(4,3,5,2) # 2
  max_result = max(4,3,5,2) # 5

  # eval() : 수식으로 표현된 하나의 식이 있을 때 계산한 결과를 수 형태로 반환
  result = eval("(3+5)*7")
  print(result) # 56

  # sorted()
  result = sorted([9, 1, 8, 5, 4]) # 오름차순
  reverse_result = sorted([9, 1, 8, 5, 4], reverse=True) # 내림차순

  # sorted() with key
  a = [('a', 30), ('b', 50), ('c', 40)]
  result = sorted(a, key=lambda x: x[1], reverse=True) # sorted(리스트, 키 속성 정렬기준)
  print(result)
  ```

- itertools : 파이썬에서 반복되는 형태의 데이터를 처리하기 위한 유용한 기능들을 제공한다.

  → 특히 순열과 조합 라이브러리는 코딩 테스트에서 자주 사용된다.

  **순열과 조합**

  모든 경우의 수를 고려해야 할 때 어떤 라이브러리를 효과적으로 사용할 수 있을까? `itertools`

  **`순열`** : 서로 다른 n개에서 서로 다른 r개를 선택하여 일렬로 나열하는 것

  - {'A', 'B', 'C'}에서 세 개를 선택하여 나열하는 경우 : 'ABC', 'ACB', 'BAC', 'BCA', 'CAB', 'CBA'

  **`조합`** : 서로 다른 n개에서 순서에 상관 없이 서로 다른 r개를 선택하는 것

  - {'A', 'B', 'C'}에서 순서를 고려하지 않고 두 개를 뽑는 경우 : 'AB', 'AC', 'BC'

  `순열의 수` : $_nP_r = n * (n - 1) * (n - 2) * \dots * (n - r - 1)$

  `조합의 수` : $_nC_r = \frac{n * (n - 1) * (n - 2) * \dots * (n - r - 1)}{r!}$

  **순열**

  ```python
  from itertools import permutations

  data = ['A', 'B', 'C']

  result = list(permutations(data, 3)) # data에서 3개를 골라 일렬로 나열

  print(result)
  ```

  **조합**

  ```python
  from itertools import combinations

  data = ['A', 'B', 'C']

  result = list(combinations(data, 2)) # data에서 2개를 뽑는 모든 조합
  ```

  **중복 순열과 중복 조합**

  ```python
  from itertools import product # 중복 순열

  data = ['A', 'B', 'C']

  result = list(product(data, repeat=2)) # 2개를 뽑는 모든 순열 구하기 (중복 허용)
  print(result)

  from itertools import combinations_with_replacement

  data = ['A', 'B', 'C']

  result = list(combinations_with_replacement(data, 2)) # 2개를 뽑는 모든 조합 구하기 (중복 허용)
  print(result)
  ```

- heapq : 힙(Heap) 자료구조를 제공한다.

  → 일반적으로 우선순위 큐 기능을 구현하기 위해 사용된다. 대표적으로 다익스트라와 같은 최단 경로 알고리즘에서 많이 활용된다.

- bisect : 이진 탐색(Binary Search) 기능을 제공한다.
- collections : 덱(deque), 카운터(Counter) 등의 유용한 자료구조를 포함한다.

  **Counter**

  파이썬 collections 라이브러리의 `Counter`는 등장 횟수를 세는 기능을 제공한다.

  리스트와 같은 반복 가능한(iterable) 객체가 주어졌을 때 **내부의 원소가 몇 번씩 등장**했는지 알려준다.

  ```python
  from collections import Counter

  counter = Counter(['a', 'b', 'c', 'b', 'a'])

  print(Counter['a']) # a가 등장한 횟수 출력 # 2
  print(Counter['c']) # c가 등장한 횟수 출력 # 1
  print(dict(counter)) # 사전 자료형으로 반환 # {'a' = 2, 'b' = 2, 'c' = 1}
  ```

- math : 필수적인 수학적 기능을 제공한다.

  → 펙토리얼, 제곱근, 최대공약수(GCD), 삼각함수 관련 함수부터 파이(pi)와 같은 상수를 포함한다.

  **최대 공약수와 최소 공배수**

  최대 공약수를 구해야 할 때는 math 라이브러리의 `gcd()` 함수를 이용할 수 있다.

  ```python
  import math

  # 최소 공배수(LCM)을 구하는 함수
  def lcm(a, b):
  	return a * b // math.gcd(a, b)

  a = 21
  b = 14

  print(math.gcd(21, 14)) # 최대 공약수(GCD) 계산 # 7
  print(lcm(21, 14)) # 최소 공배수(LCM) 계산 # 42
  ```
