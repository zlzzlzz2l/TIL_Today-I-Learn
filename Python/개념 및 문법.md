# **개념 및 문법**

## 파이썬 자료형

: 정수형, 실수형, 복소수형, 문자열, 리스트, 튜플, 사전 등

### 수 자료형

- 정수형

  : 정수를 다루는 자료형

- 실수형

  : 소수점 아래의 데이터를 포함하는 수 자료형

  : 파이썬에서는 변수에 소수점을 붙인 수를 대입하면 실수형 변수로 처리한다.

  - 지수 표현 방식

    $유효숫자e^{지수} = 유효숫자*10^{지수}$

    지수 표현 방식은 임의의 큰 수를 표현하기 위해 사용한다. 최단 경로 알고리즘(ex. 그래프)에서는 도달할 수 없는 노드에 대하여 최단 거리를 무한(INF)로 설정하곤 하는데, 이 때 가능한 최댓값이 10억 미만이라면 무한(INF)의 값으로 1e9를 이용할 수 있다.

    e나 E를 이용해서 사용 가능하다.

  실수형을 저장하기 위해 4byte나 8byte의 고정된 메모리를 컴퓨터가 할당한다.

  10진수는 `0.3 + 0.6 = 0.9`로 떨어지지만 2진수는 `0.3 + 0.6 = 0.89999`로 0.9와 최대한 가깝게 표현되지만 오차가 있다. 그래서 컴퓨터는 실수 정보를 표현하는 정확도가 떨어지기 때문에 개발 과정에서 실수값을 제대로 비교하지 못해 원하는 결과를 얻지 못할 수 있다.

  ⇒ `round() 함수`를 이용하면 위 문제가 해결되고, 권장한다.

  ```python
  a = 123.456
  round(a, 2) # 소수 셋째 자리에서 반올림

  # 123.46
  ```

**수 자료형의 연산**

- 수 자료형은 사칙연산과 나머지 연산자가 많이 사용된다.
- `나누기 연산자(/)`는 실수형으로 반환한다.
- `나머지 연산자(%)`를 사용해야 될 때가 많다. (ex. 홀수인지 아닌지 판단할 때)
- `몫 연산자(//)`는 몫을 얻기 위해 사용한다.
- `거듭제곱 연산자(**)`를 비롯해 다양한 연산자들이 존재한다.

---

### 리스트 자료형

: 여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형이다.

- 사용자 입장에서 C나 자바에서의 배열의 기능 및 연결리스트와 유사한 기능을 지원한다.
- 리스트 대신에 배열 또는 테이블이라고 부른다.

**리스트 초기화**

리스트는 대괄호(`[]`)안에 원소를 넣어 초기화하며, 쉼표(`,`)로 원소를 구분한다.

비어있는 리스트를 선언하고자 할 때 `list()` 또는 `[]`를 이용할 수 있다.

리스트 원소에 접근할 때는 인덱스(Index) 값을 괄호에 넣는다.

```python
# 크기가 n이고, 모든 값이 0인 1차원 리스트
n = 10
a = [0] * n

# [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

**리스트의 인덱싱과 슬라이싱**

인덱스 값을 입력하여 리스트의 특정한 원소에 접근하는 것을 `인덱싱(Indexing)`이라고 한다.

- 파이썬의 경우 인덱스 값은 양의 정수와 음의 정수를 모두 사용할 수 있다.
- 음의 정수를 넣으면 원소를 거꾸로 탐색하게 된다.

리스트에서 연속적인 위치를 갖는 원소들을 가져와야 할 때는 `슬라이싱(slicing)`을 이용한다.

- 대괄호 안에 토큰(`:`)을 넣어서 시작 인덱스와 끝 인덱스를 설정할 수 있다.
- **끝 인덱스는 실제 인덱스보다 1을 더 크게 설정한다.**

  ```python
  a = [1, 2, 3, 4, 5, 6]
  print(a[3]) # 4
  print(a[1:4]) # [2, 3, 4]
  ```

**리스트 Comprehension**

: 리스트를 초기화하는 방법 중 하나이다.

: 대괄호 안에 `조건문과 반복문을 적용`하여 리스트를 초기화한다.

```python
# i라는 원소를 증가시키면서 a라는 list에 넣는다.
a = [ i for i in range(10)] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 0부터 9까지 수 중에서 홀수만 포함하는 리스트
a = [ i for i in range(10) if i % 2 == 1] # [1, 3, 5, 7, 9]

# 1부터 9까지의 수들의 제곱값을 포함하는 리스트
a = [i * i for i in range(1, 10)] # [1, 4, 9, 16, 25, 36, 49, 64, 81]
```

```python
# 리스트 Comprehension
a = [i for i in range(10) if i % 2 == 1]

# 일반 코드
a = []
for i in range(10):
	if i % 2 == 1:
		a.append(i)

# [1, 3, 5, 7, 9]
```

리스트 컴프리헨션은 2차원 리스트를 초기화할 때 효과적으로 사용될 수 있다.

특히 N X M 크기의 2차원 리스트를 한 번에 초기화할 때 유용하다.

- array = [[0] \* m for \_ in range(n)]

  ```python
  n = 4
  m = 3
  a = [[0] * m for _ in range(n)]
  print(a)

  # [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
  ```

  ![image](https://user-images.githubusercontent.com/48669011/134810055-d7ff2c4a-6133-4651-a392-ef3fe62b567e.png)

아래와 같이 리스트를 초기화한다면 예기치 않은 결과가 나올 수 있다.

- array = [[0] _ m] _ n

  전체 리스트 안에 포함된 각 리스트가 모두 같은 객체(같은 주소)로 인식된다.

  ```python
  n = 4
  m = 3
  a = [[0] * m] * n
  print(a)

  a[1][1] = 5
  print(a)

  # [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
  # [[0, 5, 0], [0, 5, 0], [0, 5, 0], [0, 5, 0]]
  ```

  ![image](https://user-images.githubusercontent.com/48669011/134810072-dafaabfb-4f21-4c14-9e0a-39a747760ade.png)

  ![image](https://user-images.githubusercontent.com/48669011/134810088-56378869-a942-4772-8758-617b4583d197.png)

  특정한 위치의 값인 1행 1열의 데이터를 바꾸려고 했는데 , 모든 1 인덱스의 값들이 바뀐 걸 확인할 수 있다.

**언더바(\_) 사용하기**

파이썬에서는 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 `언더바(_)`를 자주 사용한다.

```python
# 1부터 9까지 자연수 더하기
s = 0
for i in range(1, 10):
	s += i

print(s)

# 문자열 여러번 출력하기
for _ in range(5):
	print("Hello World")
```

**리스트 관련 기타 메서드**

| 함수명    | 사용법                                       | 설명                                                                            | 시간복잡도 |
| --------- | -------------------------------------------- | ------------------------------------------------------------------------------- | ---------- |
| append()  | 변수명.append()                              | 리스트에 원소를 하나 삽입할 때 사용한다. (뒤에서부터 삽입)                      | O(1)       |
| sort()    | 변수명.sort()                                | 기본 정렬 기능으로 오름차순으로 정렬한다.                                       | O(NlogN)   |
|           | 변수명.sort(reverse=True)                    | 내림차순으로 정렬한다.                                                          |            |
| reverse() | 변수명.reverse()                             | 리스트의 원소의 순서를 모두 뒤집어 놓는다.                                      | O(N)       |
| insert()  | 변수명.insert(삽입할 위치 인덱스, 산입할 값) | 특정한 인덱스 위치에 원소를 삽입할 때 사용한다.                                 | O(N)       |
| count()   | 변수명.count(특정 값)                        | 리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용한다.                   | O(N)       |
| remove()  | 변수명.remove(특정 값)                       | 특정한 값을 갖는 원소를 제거하는데, 값을 가진 원소가 여러 개면 하나만 제거한다. | O(N)       |

`remove()`메소드 같은 경우에는 특정한 값 하나만 삭제해준다. 특정 값이 여러 개 존재해도 그 값 중 하나만 삭제한다. 전체를 삭제하는 메소드는 파이썬에 없기 때문에 아래와 같이 코드를 작성할 수 있다.

```python
a = [1, 2, 3, 4, 5, 5, 5, 5]
remove_set = {3, 5} # 집합 자료형

# remove_set에 포함되지 않은 값만 저장하기
result = [i for i in a if i not in remove_set]
print(result)

# [1, 2, 4]
```

---

### 문자열 자료형

: 문자열 변수를 초기화할 때는 큰 따옴표(`"`)나 작은 따옴표(`'`)를 이용한다.

: 문자열 안에 큰 따옴표나 작은 따옴표가 포함되어야 하는 경우가 있다.

- 전체 문자열을 큰 따옴표로 구성한 경우, 내부적으로 작은 따옴표를 포함할 수 있다.
- 전체 문자열을 작은 따옴표로 구성한 경우, 내부적으로 큰 따옴표를 포함할 수 있다.
- 백슬래시(`\`)를 사용하면 큰 따옴표나 작은 따옴표를 원하는 만큼 포함할 수 있다.

```python
s = 'Hello'
print(s)

s = "Hello \"Ahyun\""
print(s)

# Hello
# Hello "Ahyun"
```

**문자열 연산**

문자열 변수는 `덧셈(+)`과 `곱셈(*)`을 이용할 수 있다.

문자열 변수에 **덧셈(+)을 이용하면 문자열이 더해져서 연결**된다.

문자열 변수를 특정한 **양의 정수와 곱하는 경우에는 문자열이 그 값만큼 여러번 더해진다.**

문자열에 대해서도 `인덱싱과 슬라이싱`을 이용할 수 있다.

- 다만 문자열은 특정 인덱스 값을 변경할 수는 없다. (Immutable)

```python
a = "Hi"
b = "Ahyun"

print(a + " " + b)
# Hi Ahyun

a = "abc"
print(a * 3)
# abcabcabc

a = "abcdef"
print(a[2:4])
# cd
```

---

### 튜플 자료형

튜플 자료형은 리스트와 유사하지만 문법적인 차이가 있다.

- 튜플은 한 번 선언된 값을 변경할 수 없다.
- 리스트는 대괄호(`[]`)를 이용하지만 튜플은 소괄호(`()`)를 이용한다.

선언된 값을 변경할 수 없고, 적은 양의 메모리를 사용하기 때문에 튜플은 리스트에 비해 상대적으로 공간 효율적이다.

```python
a = (1, 2, 3, 4, 5)
print(a[2])
# 3

print(a[2:4])
# (3, 4)
```

**튜플을 사용하면 좋은 경우**

- **서로 다른 성질**의 데이터를 묶어서 관리해야 할 때
  - 최단 경로 알고리즘에서는 (비용, 노드 번호)의 형태로 튜플 자료형을 자주 사용한다.
- 데이터의 나열을 **해싱(Hashing)의 키 값**으로 사용해야 할 때
  - 튜플은 변경이 불가능하기 때문에 리스트와 다르게 키 값으로 사용될 수 있다.
- 리스트보다 **메모리를 효율적**으로 사용해야 할 때

---

### 사전 자료형

사전 자료형은 `키(key)`와 `값(value)`의 상을 데이터로 가지는 자료형이다.

- 리스트나 튜플이 값을 순차적으로 저장하는 것과는 대비된다.

키와 값의 쌍을 데이터로 가지며, 원하는 `변경 불가능한(Immutable) 자료형`을 키로 사용할 수 있다.

파이썬의 사전 자료형은 해시 테이블을 이용하므로 **데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리**할 수 있다.

사전 자료형은 키 값으로 데이터를 찾는다.

```python
data = dict() # 초기화 - 1
data['사과'] = 'apple' # 할당
data['바나나'] = 'banana'
data['포도'] = 'grape'

data1 = { # 초기화 - 2
	'사과': 'apple', # 할당
	'바나나': 'banana',
	'포도': 'grape'
}

print(data)
print(data1)
# {'사과': 'apple', '바나나': 'banana', '포도': 'grape'}
# {'사과': 'apple', '바나나': 'banana', '포도': 'grape'}
```

**사전 자료형 관련 메서드**

키와 값을 별도로 뽑아내기 위한 메서드를 지원한다.

- 키 데이터만 뽑아서 리스트로 이용할 때는 `keys()`함수를 이용한다.
- 값 데이터만 뽑아서 리스트로 이용할 때는 `values()` 함수를 이용한다.

```python
# 위에 선언한 사전으로 키와 값 출력

key_list = data1.keys() # 사전키로 반환
# dict_keys(['사과', '바나나', '포도'])

key_list = list(data1.keys()) # list형 데이터로 형변환
# ['사과', '바나나', '포도']

print(data1['바나나']) # banana
```

---

### 집합 자료형

집합은 아래와 같은 특징이 있다.

- 중복을 허용하지 않는다.
- 순서가 없다.

위와 같은 특징 때문에 데이터가 존재하는지, 존재하지 않는지 그 여부만을 체크할 때 효과적이다.

집합은 **리스트 혹은 문자열을 이용해서 초기화**할수 있다.

- 이 때 `set()` 함수를 이용한다.

혹은 중괄호(`{}`)안에 각 원소를 콤마(,)를 기준으로 구분하여 삽입함으로써 초기화할 수 있다.

데이터 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.

```python
data = set([1, 1, 2, 2, 3]) # 초기화
print(data) # [1, 2, 3]

data = {1, 1, 2, 2, 3} # 초기화
print(data) # [1, 2, 3]
```

**집합 자료형의 연산**

기본적인 집합 연산으로는 합집합, 교집합, 차집합 연산 등이 있다.

- `합집합`: 집합 A에 속하거나 B에 속하는 원소로 이루어진 집합 $(A \cup B)$
- `교집합`: 집합 A에도 속하고 B에도 속하는 원소로 이루어진 집합 $(A \cap B)$
- `차집합`: 집합 A의 원소 중에서 B에 속하지 않는 원소들로 이루어진 집합 $(A - B)$

```python
a = set([1, 2, 3, 4, 5])
b = {3, 4, 5, 6, 7}

# 합집합
print(a | b)
# {1, 2, 3, 4, 5, 6, 7}

# 교집합
print(a & b)
# {3, 4, 5}

# 차집합
print(a - b)
# {1, 2}
```

**집합 자료형 관련 함수**

```python
data = set([1, 2, 3])
print(data)
# {1, 2, 3}

# 새로운 원소 추가
data.add(4)
print(data)
# {1, 2, 3, 4}

# 새로운 원소 여러 개 추가
data.update([5, 6])
print(data)
# {1, 2, 3, 4, 5, 6}

# 특정한 값을 갖는 원소 삭제
data.remove(4)
print(data)
# {1, 2, 3, 5, 6}
```

**사전 자료형과 집합 자료형의 특징**

리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있다.

사전 자료형과 집합 자료형은 **순서가 없기 때문에** 인덱싱으로 값을 얻을 수 없다.

- 사전의 키(key) 혹은 집합의 원소(Element)를 이용해 **O(1)**의 시간 복잡도로 조회한다.
